There are two optimizers for racket. They are the bytecode optimize and the JIT optimizer. Typed racket adds an additional optimizer that runs before the bytecode optimizer.

Bytecode compilation occurs in five passes, they are:

1. compile
2. letrec_check
3. optimize
4. resolve
5. sfs

From the documentation in eval.c:

    The third pass, called "optimize", performs constant propagation,
    constant folding, and function inlining; this pass mutates records
    produced by the "letrec_check" pass. See "optimize.c".

The bytecode optimizer uses `struct Optimize_Info`, which is initialized using `scheme_optimize_info_create`. `scheme_optimize_info_create()` will additionally set the `Comp_Prefix` and logger for the context.

Once the `Optimize_Info` is created, `scheme_optimize_info_enforce_const()` set's the ``Optimize_info's `enforce_const`. Depending on the value of `comp_flags`, will use `scheme_optimize_info_never_inline()` to tell the optimizer to never do inlining.

At the completion of these steps, the optimizer is ready to begin. The optimizer is defined in `scheme_optimize_expr()`, and takes the scheme object returned from the letrec_check step, the `Optimize_Info` defined previously, and a context, which is initially `0`.
